---
title: "knapsack 알고리즘"
parent: Algorithms-CS
nav_order: 2

toc: true
toc_sticky: true

date: 2025-06-10
---

# <span style="color: #7153ED; font-weight: bold;">DP </span> knapsack 알고리즘

# 배낭 문제

배낭 문제는 n개의 물건과 배낭이 있을 때 (물건에는 가치와 무게가 존재한다), 배낭의 최대 용량을 초과하지 않으면서 배낭에 담을 수 있는 최대 가치의 합을 찾는 문제이다. 배낭 문제는 물건을 쪼갤 수 있는 Fraction Knapsack Proplem 과 물건을 쪼갤 수 없는 0-1 Knapsack Problem 으로 나뉜다. 이 글에서 정리한 것은 0-1 Kanpsack Problem 이다.

<img src="/assets/images/pages/cs/algorithms-cs/스크린샷 2025-06-10 오후 5.43.16.png">

# 배낭 알고리즘이 DP인 이유

해당 문제가 최대 이익을 구하는 문제라고는 해도, 결국 본질은 물건을 배낭에 넣느냐, 마느냐이다. 만약 최대 Mkg까지 넣을 수 있는 배낭이 있고 Nkg의 물건이 있을 때, 우리의 선택지는 두 가지 뿐이다. 물건을 넣어서 가방 상태가 (M-N)kg 이 되거나, 그대로 Mkg 이거나... 단순히 이 과정을 모든 물건에 대해 반복하는거다. 가방에 더 이상 공간이 남지 않을 때까지 !

그렇다면 더 나아가서 생각의 전환을 해보자. 조금 더 구체적인 예시로, 6kg 까지 넣을 수 있는 가방에 3kg 을 가진 물건을 넣었다고 해보자. 여기서 3kg 은 무조건 넣어야 하는 물건이라고 치고, 그렇다면 남은 공간 3kg 에 나머지 물건을 넣어야 하는 새로운 문제로 치환할 수 있다. 이를 한 번 더 진행해 보면, 1kg 물건을 넣어보자. 그러면 남은 공간 2kg 에 나머지 물건을 넣어야 하는 새로운 문제가 만들어진다. 즉 아래와 같은 수식이 된다.

``` markdown
최대 6kg 를 넣을 수 있는 배낭의 가치
= 3kg + (최대 3kg 를 넣을 수 있는 배낭의 가치)
= 1kg + (최대 2kg 를 넣을 수 있는 배낭의 가치)
...
```

작은 부분의 답이 큰 부분의 답이 되는 DP 의 특징이 나타난다. 즉 배낭 문제는 DP 로 풀어낼 수 있다 !

# 수식으로 접근

위에서 똑같은 로직을 반복할 때 변하는 것은 배낭의 무게, 담을 수 있는 물건의 개수 2가지이다. 그리고 경우의 수가 여러 가지 있기 때문에 이차원 배열을 사용하여 각 경우의 수에 따른 답을 저장해줘야 한다.

<img src="/assets/images/pages/cs/algorithms-cs/스크린샷 2025-06-10 오후 5.55.40.png">

``` markdown
최대이익[i][w] = 최대무게가 w인 배낭에서 i번째 물건까지 넣었을 때 최대 가치
Ex. 최대이익[4][6] = 최대 무게 6kg인 배낭에서 4번째 물건까지 넣었을 때의 가치 = 8$
```

이제 일반화해보자. 일단 처음 선택에서 2가지 경우의 수가 있다.

1. 물건의 무게가 배낭의 최대 무게를 초과할 때.

    애초에 이 경우에는 배낭에 물건을 넣을 수 없다. 아무런 변경점이 없고, k+1 까지 진행했으므로 ```dp[K+1][W] = dp[K][W]``` 된다. (여기서 dp[K][W] 는 기존에 계산해둔 최대 가치를 말한다.)

2. 물건의 무게가 배낭의 최대 무게를 초과하지 않을 때.

    이 경우에는 선택에 따라 다시 2가지 경우의 수가 있다.

    <span style="color: gray;">2-1</span> 넣지 않는다.

    이 경우는 1번의 결과와 같다. ```dp[K+1][W] = dp[K][W]```

    <span style="color: gray;">2-2</span> 넣는다.

    여기서는 생각해봐야한다. 만약 최대 6kg인 배낭에 첫 번째로 3kg 물건(4$)을 넣었다고 친다면 ```dp[1][6] = 4 + dp[0][3]``` 이 된다. 이를 일반화해서 최대 Wkg까지 담을 수 있는 배낭이 K+1 번째 물건을 담았을 때가 최대 가치라면 ```dp[K+1][W] = (K+1가치) + dp[K][W-M]``` 이 된다. 해석하자면 (K+1 번째 물건의 가치) + (그 물건의 무게 M을 뺀 (W-M)kg 으로 경우의 수를 따져서 구할 수 있는 최대 가치) = 최종 결과가 되는 것이다.

# 점화식

생각해볼 수 있는 경우의 수가 3가지 있었는데, 이를 수식으로 정리해보면 아래와 같다.

1. 물건 K의 무게 > 배낭 W의 무게 : ```dp[K][W] = dp[K-1][W]```

2. 물건 K의 무게 <= 배낭 W의 무게 : ```dp[K][W] = max(dp[K-1][W], 물건 K의 가치 + dp[K-1][W-K])```