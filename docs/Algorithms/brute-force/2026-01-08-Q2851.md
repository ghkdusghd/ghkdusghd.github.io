---
title: "백준 2851번 슈퍼 마리오"
parent: 완전탐색
nav_order: -7

toc: true
toc_sticky: true

date: 2026-01-08
---

# <span style="color: #7153ED; font-weight: bold;">Q 2851 </span> 슈퍼 마리오

## 💡 문제 요약 및 분석

슈퍼 마리오 앞에 10개의 버섯이 놓여 있다. 버섯을 먹고 점수를 100점에 가깝게 만들어 보자. 단, 버섯 먹기를 중단했다면 이후 버섯은 먹을 수 없다. 만약 첫 번째 버섯을 먹지 않았다면 그 이후 버섯도 먹을 수 없는 것이다. 버섯의 점수가 주어졌을 때 마리오가 받는 점수를 출력하자. (만약 100에 가까운 수가 98,102로 2개라면 마리오는 큰 값을 선택한다)

## 💡 알고리즘 설계

1. 입력받은 값을 순서대로 더한다. ```while(i < 10) { 연산 }```

2. 다음의 경우의 수에 따라 분기한다. 1️⃣ 이전의 값 sum에 새로운 값을 더한 임시 변수 temp == 100 이다. ```sum = temp; break;``` 2️⃣ temp > 100 이다. 그러면 이전 값 sum과 비교해야 한다. ```sum = 100 - sum >= temp - 100 ? temp : sum;```

3. sum 변수를 출력한다.

## 💡 코드

```java
public class Main {

    static int read() throws Exception {
        int c = 0, n = 0;
        while ((c = System.in.read()) > 47) n = (n << 3) + (n << 1) + (c & 15);
        return n;
    }

    public static void main(String[] args) throws Exception {
        int i = 0;
        int sum = 0;

        while (i < 10) {
            int score = read();
            int temp = sum + score;

            if (temp == 100) {
                sum = temp;
                break;
            } else if (temp > 100) {
                sum = (100 - sum >= temp - 100) ? temp : sum;
                break;
            }

            sum = temp;
            i++;
        }

        System.out.println(sum);
    }

}
```

<img src="/assets/images/pages/algorithms/brute force/스크린샷 2026-01-08 오후 4.27.13.png">

<!-- ## 💡 틀린 부분 수정 -->

## 💡 시간 복잡도, 공간 복잡도

| 시간 복잡도 | 공간 복잡도 |
| ----------- | ----------- |
| O(1)      | O(1)        |

<!-- ## 💡 다른 풀이 -->

<!-- ## 💡 느낀점 및 기억할 정보 -->
